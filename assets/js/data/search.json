[ { "title": "HunterPie v2.9.0", "url": "/posts/update-v2.9.0/", "categories": "Update, v2", "tags": "", "date": "2023-07-13 13:17:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon! Class Widgets Added support for Charge Blade Added support for Dual Blades Added support for Insect Glaive Other classes will be supported in the upcoming updates. Charge BladeThe Charge Blade helper tracks and displays all the information you need to play the Charge Blade, including weapon specific buff timers and build-ups. Insect GlaiveThe Insect Glaive helper tracks informations about your Kinsect and weapon buffs, it is designed to be able to replace the in-game HUD element. Dual BladesThe Dual Blades helper tracks informations about your Demon build-up, Piercing Bind and the state of demon mode. UI Enhancements Launch game button now allows the user to change the game to be launched, you no longer have to change it in HunterPie’s settings. Changing it directly from the button will also update your settings automatically. Completely redesigned some components to make everything look more consistent. Completely redesigned the settings window. Abnormality tray settings no longer opens a new window, it will use HunterPie’s client window instead. Completely redesigned HunterPie’s design mode. Bug Fixes HunterPie will no longer show the “Connected to Discord” message if Rich Presence integration is disabled." }, { "title": "HunterPie - An in-depth overview", "url": "/posts/hunterpie-an-in-depth-overview/", "categories": "Blog, Architecture", "tags": "", "date": "2023-06-03 04:18:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!HunterPie is an overlay for Monster Hunter games, it displays useful in-game information that are not visible to the player such as monster health, damage done, time left on your buffs and debuffs and some weapon-specific data.In order for it to work, it needs to get those values from somewhere, in this case, from the game process’s memory itself! The thing is, messing with closed source software isn’t really straightforward, depending on how a process was compiled and which language it was made on, the human readable part code is completely removed from the binaries, you won’t have the class, structs, function and method names, it will be just a bunch of bytes, offsets and instructions.This article will be split up into 2 topics, the reverse engineering and HunterPie’s architecture.The Reverse EngineeringReverse engineering is an arduous and time consuming, although fun, process. A big part of it is to assume things, I’m not a game developer myself but as a software engineer you can have a pretty good idea on how things are implemented.For instance, what is the first thing that comes in mind when you think of a health value? Probably a number, those can be usually implemented using integers or floating point decimals, in the case of Monster Hunter World, that was implemented using a float type.It is important to note that in order to assume things, you also need to understand the basics of data types and data structures. For example, how would the following data structure look like in memory in a x64 game?struct Player { float health; float maxHealth; char* name;};It would look like the following:The other important part of reverse engineering is to understand at least the basics of what happens when a program is compiled down to native machine code, what is the stack memory? The heap? If you wrote a code that access a field in a class, what would that look like in assembly? All that is important to know before diving into how HunterPie works exactly and I’ll be explaining those concepts since they’re really important.Types, Structures &amp;amp; ClassesMonster Hunter World is written in C++ and follows the OOP concepts, which means there are a lot of abstract classes, inheritance, etc.TypesMemory is just a contiguous and really big array bytes, knowing all the primitive types is really helpful because that’s how you’re going to be able to map the structures by hand, for instance, the following little endian hex value 00 00 80 3F is the float32 value for 1.0, but if you tried to read it as an int, it would represent 1065353216. Depending on how you read the bytes or how many bytes you are reading the value can change drastically. When I look at the memory, deducing the type I’m working with is very contextual.There are a couple of things you can look for when trying to figure out which types you’re looking at, for example, when you’re working with a float or double, those are usually stored in floating point registers (xmm0, xmm1, etc) or handled by floating point instructions like the movss. On the other hand, integers are usually stored in the QWORD registers (rax, rbx, etc).StructuresYou can think of a structure as a little box of primitive types, when you’re looking at memory you won’t be able to tell how many fields there are, or where a field starts or ends, that’s when putting breakpoints on the memory addresses with a debugger come useful. It allows you to see which instructions access that given memory address, here’s a simple example:movss xmm0, [eax]mov rbx, [rax+4]movss xmm1, [ebx]When looking at the previous two instructions, we can tell that rax is an structure and it has two fields, the first field is mostly likely afloat since it’s being put in a float register, the second one is a pointer since it’s being dereferenced with the offset 4, the pointer also points to another structure with a float. You could represent that as:struct RBX { float value;};struct RAX { float value; RBX* rbx;};ClassesAn easy way to think of classes in memory is to think of a struct, and the methods as functions where the first parameter is a reference to that struct. Consider the following class:class Player { public: float GetHealth() { return this-&amp;gt;m_health; } char* GetName() { return this-&amp;gt;m_name; } private: float m_health; float m_maxHealth; char* m_name;}It’s safe to say that if you compiled the previous class and wanted to “transpile” the assembly code to something more human readable, it would look something like this:struct Player { float health; float maxHealth; char* name;};float GetHealth(Player* player) { return player-&amp;gt;health;}char* GetName(Player* player) { return player-&amp;gt;name;}It’s good to know these type of things because when you’re reverse engineering a procedure in assembly, if the first parameter is an 8 byte long value that is often dereferenced with offsets, there’s a pretty big chance that procedure is an implementation of a method for that given pointer, and that helps a lot when trying to understand what that procedure does.In the case of virtual functions, things change a little bit and get more complicated, a table will be created for that class and a pointer to that table will be the first field in the structure, this was very common in Monster Hunter World, as every monster had it’s own class but they all inherited a common enemy class with virtual methods. The same class Player could be represented like this if it implemented virtual functions:struct Player { void* vptr; float health; float maxHealth; char* name;}Although the vtable is generated automatically by the compiler, the dereference and calls are done in runtime, so unlike non-virtual functions that are called by their already-known relative address, virtual functions need to be dereferenced and put into a register before being called, which makes it fairly easy to tell when you’re dealing with a virtual function.; Assuming rax is a Player*mov rbx, [rax] ; Puts the value of vptr into the rbx registermov rdx, [rbx] ; Puts the pointer to the virtual function into the rdx registercall rdx ; Calls the virtual functionMemoryThe process’s memory can be split up in two, the static memory and the dynamic memory. The static memory is the one that is embedded in the executable itself, the compiler is the one responsible for this one, this memory is where global and static variables are, this is very important because that’s how HunterPie (and the software itself) get to the values in the dynamic memory. The memory addresses in the static memory are always the same, unless you change something internally in the code and recompile your program.The dynamic memory on the other hand is well… Dynamic! The addresses are never the same, those are handled by the OS in runtime whenever your software needs more memory. The heap and the stack are also part of the dynamic memory, whenever you use the keyword new or use the malloc function, it will reserve some space in the memory and give you a pointer to that address, and for local variables the stack will be used for primitive types.The thing is, you can get to anything in the dynamic memory from the static memory, you just need the right offsets to get to your desired data, and that’s the tricky part. The process of finding the offsets from the static memory to the value you want is done backwards; First you find the value you want by scanning the dynamic memory with possible values (this is where assuming things come in) and then you put a breakpoint on the accessors of that value and look at what which instructions accesses them.Consider the following image:Let’s say the value you found is the second field in the Structure 3, the int one, when you put a breakpoint on it, you might get an instruction accessing a register plus the offset 4, something like this:mov ebx, [eax+4] ; The instruction and registers might differThat means the base address of our structure is 0x1004 - 4 = 0x1000, with that value you can now scan for all addresses that contains the value 0x1000, that will give you a list of all possible Structure 3 pointers.You can now put a breakpoint on that pointer and see the instructions, that access it, it should be something like:mov rbx, [rax+14h]By doing the same process you did previously, you’ll find the static memory, now you can always get to the Structure 3’s desired field by following that “path” of offsets, you just need to dereference the static address with the offsets you found:Static Memory -&amp;gt; (Structure 1 + 0x14) -&amp;gt; (Structure 3 + 0x4) -&amp;gt; Desired field Dereferencing the memory values from the static memory is HunterPie’s main way to extract the data from the game, it is constantly reading the game’s memory and updating the values internally.DLL InjectionSometimes you want to access the process’s data that is not in memory, in Monster Hunter Rise, for example, the player’s damage is not stored in memory, so scanning the memory for them is not possible.One of HunterPie’s core feature is to be able to track and plot the player’s damage on screen, for that to work properly I had to use another technique. Code injection and function hooks!InjectionThere are a couple of ways to inject code into other processes, but the easiest is to use Window’s kernel32. It has some very useful functions that can be used for this purpose: Open a handle to another process (OpenProcess) Allocate memory in another process (VirtualAllocEx) Write to another process’s memory (WriteProcessMemory) Load library from a path (LoadLibraryW) Create threads in another process (CreateRemoteThread)These 5 steps allow you to inject a library, you start by opening a process handle, allocating enough memory to be able to write a path to your DLL file, writing the string, finding the remote process’s LoadLibraryW address and then creating a remote thread using that LoadLibraryW as start address and the injected string as a parameter.That will make the remote process load the library you want.Function HooksFunction hooks, also known as trampoline or detouring, is a very useful technique to make a process execute code whenever a built-in function is called. If you’re interested on details on this one, take a look at MinHook.Basically it replace the first couple instructions from a procedure with a jmp instruction pointing to a relative address to where your function is, and then another jmp on your detoured function to jump back to the original instructions.This technique allows you to execute code that receives the same parameters as the original function or even change behavior of the original function.HunterPieNow that you’ve seen the basics on how to extract values from another process, it’s easier to explain HunterPie’s architecture.The application is split up in 4 modules: Core, UI, Integrations and HunterPie itself. Core: Contains the application domain entities, this includes common interfaces, configuration definitions, event models, and services that can be used by other modules. Integrations: This is the module that handles the logic for scanning each game, it’s responsible for implementing the interfaces that are on Core. UI: As the name implies, it’s the module responsible for UI related things such as visual controls, data converters, views and view models. The UI module is agnostic to the game integrations which makes the overlay components fully reusable independently of the game. HunterPie: This is the program itself, it is responsible to initialize all the other modules and handle internal features.HunterPie follows an event-based architecture model, there are events for everything that have the possibility of changing. Whenever you start a supported game, a new IContext is instantiated, that interface contains ways to access player, enemies and also game data through the IPlayer, IMonster and IGame interfaces.The previous interfaces are responsible for update values internally and also dispatch events for those values.For example, to start receiving events of the player’s level, you can just subscribe to the OnLevelChange event.[...]private void SubscribeToEvents(IContext context){ context.Game.Player.OnLevelChange += (source, args) =&amp;gt; { Log.Info($&quot;The player is now level {args.MasterRank}&quot;); }}[...]Whenever HunterPie detect that the player’s level changed in-game, it will update the internal value in the IPlayer class and dispatch the event to all its subscribers.Detecting values changesHunterPie tracks values using two different approaches, the first one is by constantly scanning the game’s memory for static addresses and offset paths to the data it needs to works. The second one is by injecting a native library inside the game and opening a communication layer between HunterPie and the game.Memory scanningEvery supported game has a map file containing addresses and offsets that can be used, the map file looks something like this and is loaded in runtime whenever the game starts.# AddressesAddress QUEST_DATA_ADDRESS 0x506F240# OffsetsOffset QUEST_STATE_OFFSETS 0x54 # This supports an array of integers tooThen in the scanner implementation you can fetch those values and read the memory with any type you want, this includes reading complex structures to reduce the amount of P/Invoke calls when reading multiple values.[ScannableMethod]private void GetQuestState(){ var questState = (QuestState)Memory.Deref&amp;lt;int&amp;gt;( AddressMap.GetAbsolute(&quot;QUEST_DATA_ADDRESS&quot;), AddressMap.Get&amp;lt;int[]&amp;gt;(&quot;QUEST_STATE_OFFSETS&quot;) ); QuestStatus = questState.ToStatus(); IsInQuest = questState == QuestState.InQuest;}The ScannableMethod attribute on top of the method name allows that method to be automatically injected into HunterPie’s ScanManager, the scan manager will run all scannable methods in a background thread every couple milliseconds (this can be configured by the user). It also handles failures and has an internal “circuit-breaker” strategy to remove troublesome scannables if they fail too often.Handling failures is a mandatory thing, sometimes process pointers are not valid anymore and HunterPie can read garbage values that could cause a crash if not handled correctly.Native InterfaceThe second value tracking strategy is through a native interface, first HunterPie injects a statically linked library into the game. Once this library is loaded, it automatically opens a TCP socket server that starts listening for incoming connections from HunterPie.To exchange data between the HunterPie application (made in C#) with HunterPie’s native interface that is injected into the game (made in C++), they use a binary protocol, the messages look like this:namespace Core::Server::Models{ typedef uint32_t IPCMessageVersion; enum IPCMessageType { INIT_IPC_MEMORY_ADDRESSES, INIT_MH_HOOKS, GET_HUNT_STATISTICS, DELETE_HUNT_STATISTICS, CLEAR_HUNT_STATISTICS, UNKNOWN }; struct IPCMessage { IPCMessageType type; IPCMessageVersion version; };}Every message will receive the IPCMessage structure as its first field, allowing HunterPie to call the right MessageHandler based on the IPCMessageType and IPCMessageVersion.The OverlayThe overlay is one of HunterPie’s main features and is also the most used one, the architecture is very similar to Model View ViewModel (MVVM) pattern but instead of having a “Model”, HunterPie has what I call IContextHandler. The Views is responsible for the UI itself, it’s what the user will visualize; The ViewModel is responsible to control the data the View will display through data bindings; The IContextHandler is the one responsible to subscribe and handle HunterPie game context’s events. It has direct access to both the View and to the ViewModel it is controlling, but they cannot see the IContextHandler.This architecture makes it really easy to test how the UI is behaving since we can easily create a mock the IContext and simulate in-game changes.The overlay is composed by Widgets, each Widget has its own scope and responsibility, you can have the Monster Widget, that is responsible to display Monster’s information, the Damage Meter Widget that displays the damage done by the players in your party, the Abnormalities Widget that tracks and displays your buffs and debuffs timers, and so on.Every Widget is agnostic to what game you are playing, so it doesn’t matter whether you’re playing Monster Hunter World or Monster Hunter Rise, the Widget components will be reused for both games.Hunt ExportsAnother cool feature, although very recent, is the ability to export hunts. Since HunterPie is constantly tracking in-game information, it is able to track vital information to build a history graph of what happened in your game session.It displays the party members, their damage over time and the (de)buff uptimes. This is possible because since HunterPie follows an event-based architecture, it can “recreate” what happened in-game based on the order that HunterPie’s internal events were dispatched!At the end of every hunt, HunterPie will automatically serialize that data and upload it to HunterPie’s backend and link the upload to the user’s account.ConclusionsHunterPie has been released 4 years ago, the current architecture was very different years ago and is the result to solve solutions I had in the past due to a not well-thought-of architecture. It also took me years to learn things I know now about reverse engineering now, but one thing I can say is that the process of learning all of it was very fun, interesting and changed the way I see software engineering nowadays." }, { "title": "HunterPie v2.8.0", "url": "/posts/update-v2.8.0/", "categories": "Update, v2", "tags": "", "date": "2023-04-19 13:54:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon! HunterPie Account - Hunt ExportThe Hunt Export dashboard has been added, it is still a very new and will be actively worked on in the upcoming updates, the goal is to make it as accurate and useful possible, with uptimes, damage points, information from party members, monsters, quest details, etc.As of today, it currently displays: Quest time Real hunt time (how long it actually took to hunt down a monster) DPS graph Party members Enrage uptime for each monster Abnormalities uptimes Quest details Attention: Exported SOS quests are still not accurate due to how they work. That will be worked on in the future.For more information about this feature, refer to the documentation." }, { "title": "The development of HunterPie", "url": "/posts/development-of-hunterpie/", "categories": "Blog, UI", "tags": "", "date": "2023-03-28 13:43:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!Some contextI have been actively developing and maintaining HunterPie and all its dependencies for about 4 years now, the reason why I’m writing this post is not only to show the progress of HunterPie itself, but to also document the progress I had as a software engineer myself.How it all started…It all started back in 2018 with Monster Hunter World, at the time there was 2 overlays that people used: Smart Hunter and Hello World; As someone who is interested in UI and good looking applications, none of them really stood out to me, not only that, but both of them were pretty limited and not really user friendly, in order for you to customize them, you would need to open JSON files in your text editor.With that in mind, I decided to make my own, not only to make something that would look better to me, but that would also help me learn more about software engineering, reverse engineering, UI/UX principles and so on.First IterationsHunterPyHunterPy was made in Python (hence the Py at the end), a dynamic programming language that is really easy to understand due to its simple syntax, however, is not the best language to make good looking UIs and also not the best language to deal with memory reading, the heart of HunterPie. Despite those, I learned a lot while developing it and used a lot of the fundamentals to implement the next iteration of HunterPie.After some time working on HunterPy, I had a simple overlay working pretty alright, all it had was monster health bars but it was enough to get some friends to use it and test it for me. HunterPy user interfaceSome key features that I always wanted to keep were: Discord Rich Presence The overlay A console Settings that you could interact with, instead of a configuration.json fileOne of the problems with making windows with Python is that you can’t just compile the whole software into a single executable due to how Python works, there are some solutions but they generate a bunch of extra files or huge binaries that would be really painful to distribute if I ever wanted other people to use it.That’s when I decided to rewrite everything in another language, something I could compile and just distribute in a nice little package without worrying too much about the package size.The first iteration…The reason why HunterPie is called HunterPie is because it didn’t make sense to keep the Py suffix anymore as the application was no longer being developed in Python, but I really liked how HunterPy sounded, so I just changed the suffix to keep the same sound without making a reference to Python.The next iteration of HunterPie’s user interface looked like this: HunterPie v1 alpha client HunterPie v1 alpha client settingsThe monster widget looked like this: HunterPie v1 alpha Monster WidgetThis iteration had not only the monster health bar, but also the Harvest Box tracker and Specialized Tool trackers.…the next iteration…The next iteration happened 4 months after the first release of HunterPie v1.0.0.0. I learned a lot more about the UI framework I was using and completely designed the client, not only that but I also created my own UI components for the settings window. This next iteration also had more features like: full localization support so other people could localize HunterPie to their languages; a damage meter widget and the abnormalities tracker widget. HunterPie v1 client HunterPie v1 client settingsThe two main widgets of HunterPie looked like this: HunterPie v1 Monster Widget HunterPie v1 Damage Meter WidgetThe design for the Damage Meter was inspired by Shinra Meter, a TERA damage meter overlay that I used a lot when playing the game back in the days.…and the last iterationThe last iteration of HunterPie v1 happened a few months after the previous one, at that point HunterPie had many new features, new widgets for the overlay, it could export the player’s current build to Honey Hunters, export all the charms and decorations your character had, it also had plugins support, HunterPie Native was also a thing, a way that HunterPie was able to communicate directly with the game which allowed many pretty cool things to happen.In this iteration the design structure of the client didn’t change much, but the colors and the settings page did.I wanted a cleaner design for the client, and changing the colors to a baby blue instead of red made things look more modern and less aggressive, not only the accent color changed but HunterPie’s logo also changed to be white instead of red. HunterPie v1 last iteration clientAdding a blur effect to the background also made the client to look more modern, similar to Window’s native acryllic effect.As for the settings page, having every setting in a single component was getting way too cluttered and messy, so I added different tabs for each one of the features, the settings were also aligned in a way so the setting label would be anchored to the left and the actual control for that setting would be on the right-most side, that was a way to solve the weird alignment of the previous iteration. HunterPie v1 last iteration client settingsThe main widgets design also changed, the Monster Widget had another design overhaul to look more simple and modern: HunterPie v1 last iteration Monster WidgetAnd the damage meter got a damage graph! HunterPie v1 last iteration Damage Meter WidgetHunterPie v2The reason why I started rewriting HunterPie from scratch to what would become v2 is because its predecessor had a really messy code base, it got to a point where adding new features was really hard and adding support for the upcoming game (Monster Hunter Rise) would be actually impossible. Everything in v1 was heavily tied to Monster Hunter World, not only that but the whole UI was strongly tied to HunterPie’s core code.So for v2 I decided to fix some issues legacy had: The client UI had to look more modern and clean: I don’t think legacy’s UI was bad, but I don’t think it was great either. The settings page to be generated automatically: This is one of legacy’s biggest issues for me as a developer, everytime I added new settings I had to also create the UI components for it manually. The settings should be saved automatically on change: Legacy couldn’t detect if the settings were changed, so the user had to click on the Save button everytime they made changes. Support any Monster Hunter game: Legacy could only support Monster Hunter World. Write the code in a way that Core code is separate from the UI code: Legacy code didn’t have this distinction, core code could access the UI’d and vice-versa.I will explain each one of those points and how I solved them in a later post, but here’s the result: HunterPie v2 clientThe first thing you can notice is how the colors are much more consistent, they make sense together, it’s no longer a mix of warm and cold colors. The icons are also perfectly aligned now, and they’re all consistent and match the rest of the UI.As for the settings window, I kept the same idea and structure of its predecessor, however it is now possible to search for settings by their label. HunterPie v2 is also capable of automatically saving the settings whenever something changes, so there’s no need for a Save button anymore. HunterPie v2 client settingsNow for the two most used overlay widget, the monster widget got a design overhaul to match the rest of the client UI, in fact, all widgets have gotten a design overhaul to make the UI consistent amongst themselves: HunterPie v2 Monster WidgetAnd the damage meter had a lot of UI improvements too: HunterPie v2 Damage Meter WidgetFinal ConsiderationsThere were a lot of enhancements to HunterPie’s user interface throghout time, most of the things were just trial and error, see what works and what does not. Some came with time and experience after I started working as a software engineer and started having more contact with real world software.The user interface is just the tip of the iceberg for HunterPie, there’s a lot going on behind it, a lot of time and effort put into researching the games, designing and coding HunterPie’s UI, coding internal things used in the core of HunterPie, coding the native part that is required for some features, coding the backend, maintaining all the infrastructure, etc.And of course, each one of those individual pieces that make HunterPie work the way it does deserve their own post. Fun fact: I have spent +2,1K hours on HunterPie (Client and Server) and a couple hundred hours reverse engineering both Monster Hunter World and Monster Hunter Rise. Which is kinda insane, honestly." }, { "title": "Hunt Export", "url": "/posts/hunt-export/", "categories": "Documentation, Account, Feature", "tags": "", "date": "2023-03-27 14:09:00 +0800", "snippet": "AboutHunt export is one of HunterPie Accounts feature, it will automatically keep track and upload all quests you complete successfully, keeping a history of all your previous hunts.The hunt export is separated into two pages, the summaries and the dashboard.SummariesThe summaries page displays all the hunts that are available for you to visualize in the dashboard. Note that the amount of hunts are limited by your account tier.Account Tiers Tier Access Free Up to 7 days of hunts. Low Rank ($1) Up to 30 days of hunts. High Rank ($5) Unlimited Tempered ($10) Unlimited Arch-Tempered ($20) Unlimited DashboardThe dashboard is where you can visualize the details of the hunt, this includes: Damage over time; Enrage uptimes and activation spans; Abnormalities uptimes and activation spans; Party members; Other information about the quest and monsters; Note: More information will be added in the future, this includes deaths and more detailed information about damage and weapon attacksKnown Issues Quests that were joined mid-hunt are not tracked properly Otomos are not displayed Really old exported hunts have 100% enrage uptimes" }, { "title": "HunterPie v2.7.0", "url": "/posts/update-v2.7.0/", "categories": "Update, v2", "tags": "", "date": "2023-02-10 07:23:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!HunterPie v2.7.0 is finally here with a lot of new features! HunterPie Account - Hunt ExportThe Hunt Export is a feature that will be split in two parts, the first one is coming on this version of HunterPie, it consists of tracking your hunt data and once the quest is over, exporting it and linking it to your HunterPie account so you can see that data in a dashboard.The second part of this feature will come on v2.8.0, which is the actual UI that you can use to visualize the exported data.Here’s a sneak peek of the dashboard that will be released in v2.8.0: Note: The UI in the video is not the final result and WILL be changed to look better. It is also possible to turn off this feature if you’re not interested in getting your hunts uploaded. HunterPie Account - Settings Sync HunterPie is now able to synchronize your local settings so you should never lose your settings again Damage Meter Widget HunterPie is now able to track companion’s damage Activities Widget Added Harvest Box tracker for Monster Hunter World Added Argosy tracker for Monster Hunter World Added Steamworks tracker for Monster Hunter World Added Meowmasters tracker for Monster Hunter World Note: It is also possible to turn off activities separately if you are not interested in seeing one of them Abnormalitites WidgetAdded support for new abnormalities: Monster Hunter Rise: Minor Bubbleblight Dango Defender Frenzy Immunity Leeched Sharpness Extension Dango Hunter Dango Connector Agitator Defiance Interpid Heart Heroics Peak Performance Dragonheart Pre-Sleep Health Regen. (Bleed) Powder Mantle (Red) and (Blue) Strife (S) and (L) Maximum Might Berserk Status Trigger Monster Hunter World: Demondrug Mega Demondrug Armorskin Mega Armorskin Bug Fixes Fixed bug where HunterPie would remove the last players from party if someone else dropped the session in Monster Hunter World Fixed bug where HunterPie would not detect multiple players with the same name Fixed bug where HunterPie would fail to reach the backend if header had a new line character in it Fixed bug where HunterPie would try to hash all files during self-updates instead of only the required files for the update" }, { "title": "Troubleshooting", "url": "/posts/troubleshooting/", "categories": "Documentation, Issues", "tags": "", "date": "2022-11-27 01:43:00 +0800", "snippet": "If you’re having an issue with HunterPie like crash or freezes, do the following: If you’re having freezing issues or crashes, skip to Memory DumpMemory DumpDebugging a software without any data that can be analyzed is really hard, so if your HunterPie is constantly freezing, you can try generating a memory dump of HunterPie’s process so I can analyze it and see if there’s anything weird going on. To generate a memory dump, do the following: Open the command prompt by opening Window’s search and typing cmd Run the following command dotnet tool install --global dotnet-gcdump Once the tool finishes installing, open Windows’s Task Manager (Ctrl+Shift+Esc), click on the Details tab and look for a HunterPie.exe, the details tab should have a column labeled as PID, you’ll need to grab HunterPie’s PID. Run the following command, replacing &amp;lt;PID&amp;gt; with HunterPie’s actual PID that you got from the previous step: dotnet gcdump collect -p &amp;lt;PID&amp;gt; It will print something like:Writing gcdump to &#39;&amp;lt;PATH_TO_GCDUMP_HERE&amp;gt;&#39;... Finished writing &amp;lt;NUMBER_OF_BYTES&amp;gt; bytes.Now that you’ve dumped HunterPie’s memory to a .gcdump file, just send that file to me on Discord: Haato#0001 or in HunterPie’s official server." }, { "title": "Player Hud Widget", "url": "/posts/player-hud-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-11-27 01:43:00 +0800", "snippet": "The Player Hud Widget is responsible for tracking and displaying the data related to your character’s health and stamina, as well as tracking your weapon’s sharpness.Widget StructureHealth barThe health bar can be broken down into 5 pieces: Maximum Possible Health: This is the white bar that’s behind all the other bars, it represents your maximum possible health, in Monster Hunter Rise, this is the bar that shows how much your actual health can be expanded to by consuming the green birds. Max Health: This is represented by the dark bar behind the recoverable health, heal and health. Recoverable health: This is your health that can be recovered naturally over time. Heal: This is the bar that will represent the healing when you’re consuming an item that can heal your life, it’s represented by the light green bar. Health: This is your actual health, it’s represented by the green bar.Stamina BarThe stamina bar can be broken down into 4 pieces: Maximum Possible Stamina: This is the maximum possible stamina you can have, it’s represented by the white bar that’s behind all the other bars. In Monster Hunter Rise, this is the bar that shows how much your actual stamina can be expanded to by consuming the yellow birds. Max Stamina: This is the bar that shows you what’s your current maximum stamina, represented by the dark bar behind the stamina bar. Recoverable stamina: This bar will show how much stamina you can recover by eating rations or meat, it’s represented by the hollow bar with the red border around it. This only happens in Monster Hunter Rise. Stamina: This is your actual stamina, it’s represented by the orange-ish bar.AbnormalitiesWhen your character is suffering from a debuff, your health bar or stamina will change it’s color to match the element that is currently active. Fire Poison Bleed Nat. Heal Water Ice Effluvia SharpnessHunterPie tracks your sharpness, and displays it in a gauge. The colors for each level are the following: Red Orange Yellow Green Blue White Purple It’s also possible to override those colors with theme files, in case you want custom colors for each level.&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_BROKEN&quot;&amp;gt;#000000&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_RED&quot;&amp;gt;#D13232&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_ORANGE&quot;&amp;gt;#F78B00&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_YELLOW&quot;&amp;gt;#F7E024&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_GREEN&quot;&amp;gt;#5BF77F&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_BLUE&quot;&amp;gt;#49B2E3&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_WHITE&quot;&amp;gt;#EAF5F4&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_PURPLE&quot;&amp;gt;#cd55e6&amp;lt;/Color&amp;gt;In-Game HUDTo avoid cluttering the screen, you can disable the in-game HUD:Monster Hunter Rise" }, { "title": "HunterPie v2.6.0", "url": "/posts/update-v2.6.0/", "categories": "Update, v2", "tags": "", "date": "2022-11-27 01:18:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!HunterPie v2.6.0 is finally here with a lot of new features! Player HUD WidgetThis new widget is responsible for displaying your character’s health, stamina and sharpness in a simple health bar, it also displays how many hits you have left until your sharpness level decreases.The widget’s design is the following:You can also see it in action in the video below:The player HUD does not display buffs on top of the player’s health bar, for that you need to use the Abnormalities Widget. Tip: Refer to the documentation for more information. OptimizationsThis update also brings some minor and major optimizations to HunterPie, below you can see the benchmark comparing both the old scanning method and the new one.Although the new implementation is only 12% faster, it is a lot more stable when you compare the slowest scan passes compared to the old implementation. Other changes Added hotkey to toggle overlay (default: Ctrl+Alt+O); Added support for new abnormalities: Adrenaline Rush, Sleep, Stun, Paralysis; HunterPie now downloads localization files from the CDN instead of updating them only during updates; Apex monsters no longer display the capture icon; Introduced Smart Events to handle internal events within HunterPie’s core; Bug Fixes Fixed memory leak due to smooth bar animations; Fixed memory leak due to internal events not being unsubscribed on game exit; Fixed Qurio part health displaying even when Qurio wasn’t active for that specific part; Fixed HunterPie crashing when loading an invalid theme file; Fixed HunterPie crashing or throwing a lot of exception messages in the console during the scanning process; Fixed HunterPie not cancelling self-update when binaries are not downloaded successfully;" }, { "title": "HunterPie v2.5.0", "url": "/posts/update-v2.5.0/", "categories": "Update, v2", "tags": "", "date": "2022-11-03 06:29:00 +0800", "snippet": "HunterPie v2.5.0 is finally here with a lot of new features! Monster Widget - QurioHunterPie now supports Qurio monsters: Added Qurio Threshold bar; Added support for Qurio parts; Added Qurio monster icon; Before entering Qurio state After entering Qurio state Abnormalitites WidgetAdded support for the following abnormalities: Monster Hunter Rise: Sunbreak Bloodblight; Grinder (S); Coalescence; Demondrug; Mega Demondrug; Armorskin; Mega Armorskin; Damage Meter Added maximum deaths for quest; Patch Notes TabHunterPie has a new dedicated tab for the latest patch notes. Bug Fixes Fixed Capture indicator appearing for Qurio monsters; Fixed submarines total item count miscalculation; Fixed bug where HunterPie wouldn’t retry requests in case of timeout;" }, { "title": "HunterPie v2.4.0", "url": "/posts/update-v2.4.0/", "categories": "Update, v2", "tags": "", "date": "2022-10-13 02:16:00 +0800", "snippet": "HunterPie v2.4.0 is finally here with a lot of new features! AccountsHunterPie accounts will be part of HunterPie’s core features, although it is not required to have one to use the overlay, HunterPie will be getting more account-related features in the upcoming updates. Here are some of the planned features that will require an account: HunterPie configuration cloud synchronization; Hunt details; Tip: Refer to the documentation for more information. Game saves backup This feature requires an account.Having a HunterPie account will allow HunterPie to automatically backup your save files and upload them to the cloud. You can read more about the backup feature here. Damage Meter - Monster Hunter World HunterPie can now calculate your damage when in expeditions and Guiding Lands. Warning: This feature requires Stracker’s loader to work properly. UX enhancementsHunterPie’s client animations have been reworked and some new animations have been added when interacting with the main client window. Added transition animations when opening different views in the main window; Added animations to tooltips when hovering over UI components; Added smooth scrollbar; Added fade-in and slide-in animations to setting elements when changing setting tabs; Changed button colors and rounded their corners; Added Github button to the sidebar container; Bug Fixes Fixed a bug where Meowmasters step counter would show as 6/5 when Meowmasters are back in town." }, { "title": "HunterPie Account", "url": "/posts/account/", "categories": "Documentation, Account, Feature", "tags": "", "date": "2022-10-10 14:08:00 +0800", "snippet": "AboutHunterPie Account is one of it’s core features, although not necessary, it’s highly recommended to have an account because that way you can use HunterPie at its fullest.Exclusive FeaturesHaving an account will give you the access to the following features: Hunt Export: Your hunts will be tracked and uploaded so you can visualize them in a dashboard. You can read more here Remote HunterPie settings: Your configurations will be tied to your account instead of being saved locally only. Automatic game saves backup: HunterPie will automatically backup your game saves and upload them to the cloud. You can read more here Note: More account-exclusive features will be added in the future.Creating an account Click on the Sign Up button in your HunterPie’s side bar; Fill the required information and click on the Register button; HunterPie will automatically send you an email to verify the email associated to your account; After verifying the email, you can now login into your account! Warning: The process of receiving a verification email should be instant but might take a few minutes depending on your email provider. Make sure to also check your spam and trash folders.Supporter AccountYour account will be automatically turned into a supporter account if you create it using the same email you used when creating your Patreon account. By being an active supporter you also get access to BETA updates and upgrades to some of the existing features.Supporter TiersThere are 4 different supporter tiers, depending on your tier, you will get an enhancement to the existing HunterPie features. The available tiers can be found here." }, { "title": "HunterPie Account - Saves Backup", "url": "/posts/saves-backup/", "categories": "Documentation, Account, Feature", "tags": "", "date": "2022-10-10 13:33:00 +0800", "snippet": " This feature can be disabled in your account settings.One of the features of having a HunterPie Account is that HunterPie will automatically backup your save and upload it to the cloud, this way you can play Monster Hunter games without worrying about your save getting corrupted.The backups are available under your account details screen.How it works?HunterPie will automatically handle backups of your game saves, the limit on how often and how many backups you can have at once depends on your type of account. Account Number of Backups (total) Rate limit Standard 2 backups (total) Once every 72 hours Supporter 5 backups (total) Once every 24 hours Backup list You can download the backup file by clicking on the button, HunterPie will download the file into the HunterPie/Backups folder as a .zip file. To open the Backups folder quickly, you can also press the button. In case you want to manually delete a backup file, just click on the button. Warning: Keep in mind that deleting a backup file manually WILL NOT reset your rate limit." }, { "title": "HunterPie v2.3.0", "url": "/posts/update-v2.3.0/", "categories": "Update, v2", "tags": "", "date": "2022-08-24 12:54:00 +0800", "snippet": "HunterPie v2.3.0 is finally out and brings new features and fixes! Themes Added theme support, it is now possible to fully customize every Widget appearance. Activities Widget Added Meowmasters tracker. Added Cohoot Nest tracker. Minor design changes to the widget components. Activities Widget Damage Meter Widget Added Master Rank to be displayed on top of the player’s weapon icon. Added Otomo’s damage tracker. Bug Fixes Fixed Chat Widget. Fixed bug where HunterPie would crash if someone left the party unexpectedly. Fixed bug where DPS would be recalculated if a party member changed their weapon in the tent." }, { "title": "HunterPie v2.2.0", "url": "/posts/update-v2.2.0/", "categories": "Update, v2", "tags": "", "date": "2022-07-20 13:18:00 +0800", "snippet": "HunterPie v2.2.0 is finally out and brings a lot of new features and enhancements!General Upgraded required .NET version to 6.0, you can download it from here. Added support for the following Monster Hunter Rise abnormalities: Chain Crit (Under armor skills) Stinkmink (Under consumables) Added option to configure animations framerate Added localization for enumerations Added Master Rank to Discord Rich Presence for Monster Hunter Rise Minor optimizations to widgets Changed abnormality settings tab icon to a proper iconDamage Meter WidgetOne of the most asked features is now available for Monster Hunter Rise! The Damage Meter tracks yours and your team mates damage and display it in a modern-looking meter and plotting graph. The following strategies were added to the damage meter graph: Plot by total damage Plot by DPS The following strategies were added to the DPS calculation: DPS relative to join time DPS relative first hit DPS relative to quest timer The way how HunterPie calculates the damage done by each player is by looking at each individual hit and summing them up, right now it will ONLY considerate the damage done by each player’s weapon. The following damages are not accounted for when calculating damage done by each player: Environmental damage Damage done by other monsters Damage done by ailments (e.g: Poison, blast, etc) Note: Damage calculation may change in the future. Tip: Refer to the documentation for more information.Monster Widget Added monster weaknesses Added capture indicator Tip: Refer to the documentation for more information.HunterPie Native InterfaceHunterPie Native Interface is responsible for sending data from inside the game’s process to HunterPie, this is required for features that depends on function hooking such as Monster Hunter Rise damage meter.Bug Fixes Fixed unmapped part names for some monsters in Monster Hunter: World Fixed memory leak due to in-memory custom font Fixed enrage counter Fixed HunterPie logo asymmetry Fixed widgets not being closed properly after Monster Hunter World is closed" }, { "title": "Specialized Tool Widget", "url": "/posts/specialized-tools-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-06-16 22:00:00 +0800", "snippet": "The Specialized Tool Widget is responsible for tracking and displaying your primary and secondary equipped specialized tools cooldown and timers. They also visually indicate which mantle or booster it is currently tracking by their icons and color. This Widget is only available for Monster Hunter: World.Widget Structure Specialized Tool Widget Structure" }, { "title": "HunterPie v2.1.0", "url": "/posts/update-v2.1.0/", "categories": "Update, v2", "tags": "", "date": "2022-06-15 10:57:00 +0800", "snippet": "HunterPie v2.1.0 contains the second part of the full Monster Hunter World support.General Added supporter badge on top of the HunterPie’s window. HunterPie no longer saves its configurations on exit. Adjusted HunterPie settings window margin. Adjusted Damage Meter icon in the settings window.Monster Hunter: WorldMonster Widget Added tenderize information to monster’s part health bars. Severable and normal parts now have different colors.Specialized Tool WidgetThe specialized tool widget is the one responsible for showing your primary and secondary specialized tool cooldown and timer. Tip: Refer to the documentation for more information.Bug Fixes Fixed a bug where widgets wouldn’t be hidden in NPC dialogs even when the “Hide when HUD is open” option is enabled in Monster Hunter Rise. Fixed a bug where HunterPie would crash if there were duplicate constant names in the map file. Fixed a bug where Training Dojo state bar size would go back and forth when there were 0 days left for training." }, { "title": "Damage Meter Widget", "url": "/posts/damage-meter-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-06-15 10:21:00 +0800", "snippet": "The Damage Meter Widget is responsible for tracking and displaying yours and your party members damage and damage per second, as well as plotting everything in a graph for better understanding of your hunts.Widget Structure Damage Meter widget demonstrationDamage AccuracyMonster Hunter RiseTo calculate the damage for Monster Hunter Rise, HunterPie will sum every hit damage and assign it to whoever did the damage. This does not consider: Environmental damage Damage done by palamutes/palicos Damage done by companions Damage done by ailments (e.g: poison, blast) Damage done by other monsters Warning: Hitting a dead monster will still count as damage done to a monster. This is a known issue and will be fixed eventually.SettingsPlayer colorsYou can change yours and your party members color by going to the settings tab and clicking on the color configuration.Damage plotThe damage meter widget has a built-in plot graph, by default it shows your damage per second over time, however, you can also change it to display total damage instead. Note: Changing the plot mode while in a hunt will not update the previous points that were already plotted in the graph.DPS CalculationBy default, HunterPie will calculate the damage per second based on the quest timer, however, this can be inaccurate especially when joining in-progress quests (such as SOSes), you can change the DPS calculation strategy in the Damage Meter settings. Strategy Description Relative to quest The quest timer will be used to calculate players DPS Relative to join The time when each player joined the quest will be subtracted from the quest timer when calculating players DPS Relative to first hit The time when each player hit a monster for the first time will be subtracted from the quest timer when calculating players DPS " }, { "title": "HunterPie v2.0.23", "url": "/posts/update-v2.0.23/", "categories": "Update, v2", "tags": "", "date": "2022-05-02 03:51:00 +0800", "snippet": "HunterPie v2.0.23 contains the first part of the full Monster Hunter World support.General Changed Mount ailment name to Ride for Monster Hunter Rise Changed visual component for hotkeys Changed visuals of ComboBox Changed HunterPie client color scheme to be more consistent Added Offensive Guard abnormality for Monster Hunter RiseConfigurationSince HunterPie can support multiple games, it allows you to configure games separately, so you can have a different overlay configuration for each game.Choosing which game to configure is rather simple, just choose the game by its name in the box in the bottom of HunterPie’s settings window.Monster Hunter: WorldOne of the main reasons HunterPie v2 exists is to support multiple games from the Monster Hunter series, this update brings support for Monster Hunter: World and some of the main overlay Widgets that v1 has at the moment.OverlayMonster WidgetCompared to HunterPie legacy, the monster widget now has 100% accurate lockon detection, supports more than 3 monsters. Tip: Refer to the documentation for more information.Abnormalities WidgetRight now, HunterPie supports most of the abnormalities Monster Hunter: World has, with exception of potions that last forever like Demondrug and Armorskin. Tip: Refer to the documentation for more information.Damage Meter WidgetThe damage meter is something that’s part of the core of HunterPie legacy, in v2 there were a lot of enhancements: Quest timer is now 100% accurate and displays the right time even for in-progress quests (like SOSes)." }, { "title": "Chat Widget", "url": "/posts/chat-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-04-01 10:54:00 +0800", "snippet": "The Chat Widget is responsible to display in-game messages from other players.Widget StructureWhy does it exist?Monster Hunter: Rise’s built-in chat was made for Switch and not for PC, making it really difficult to read messages and also keep track of them. Whenever you get a message, it stays on screen for about 10 seconds and then fades away, if you want to read the message again, you are obligated to go to your in-game settings, open the chat messages and then open the chat, which can become very annoying if you play online with friends often.HunterPie’s chat solves this issue by showing only the player messages, and it also shows the widget whenever you press Enter to type in the chat. Warning: Preset messages will not be shown in the chat." }, { "title": "Activities Widget", "url": "/posts/activities-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-04-01 10:39:00 +0800", "snippet": "The Activities Widget is responsible for tracking and displaying the data from side activities in the game as Submarines, Training Dojo, etc.Widget StructureSupported ActitivitesMonster Hunter: Rise Submarines Training Dojo Meowmasters and other activities will be supported in the future." }, { "title": "HunterPie v2.0.22", "url": "/posts/update-v2.0.22/", "categories": "Update, v2", "tags": "", "date": "2022-04-01 09:28:00 +0800", "snippet": "HunterPie v2.0.22 brings some new features, fixes and optimizations.General Added support for Monster Hunter Rise v3.9.1.0 Added Party state and size to Discord Rich Presence Added option to automatically close HunterPie when game is no longer running Added option to start HunterPie on background Added option to not show confirmation popup on exit Added option to hide individual widgets when the in-game HUD is visible (e.g when you’re in camp, talking to NPCs, with game menu open, etc) HunterPie now updates settings file in real time Optimizations to the UI thread Optimizations to the Scan thread Minor visual enhancedments to the main window HunterPie now displays the last config sync time in the Settings tabActivities WidgetThe Activities Widget tracks and displays your Submarines, Training Dojo and Training buddies data. Tip: Refer to the documentation for more information.Chat WidgetThe Chat Widget displays messages from your chat so you won’t lose track of them during a hunt. This widget is designed to only show actual messages, no NPCs, no system messages nor notifications from the game. Tip: Refer to the documentation for more information.Abnormalities Widget Added Protective Polish Added Arc Shot: Brace Added Arc Shot: AffinityBug Fixes Fixed a bug where HunterPie would still try updating Rich Presence when it’s disabled Fixed bug where HunterPie would crash when trying to unload an unitialized widgets Fixed CDN download causing HunterPie to crash due to unauthorized file access Fixed wrong string for Training Dojo setting Fixed default widget positions Fixed bug where HunterPie would not parse floats separate by comma due to cultural dependent system Fixed memory leak due to garbage memory values in the string lengths, causing HunterPie to read a large array of bytes" }, { "title": "HunterPie v2.0.21", "url": "/posts/update-v2.0.21/", "categories": "Update, v2", "tags": "", "date": "2022-03-02 03:51:00 +0800", "snippet": "HunterPie v2.0.21 brings some new features, fixes and design changes.General Added support for Monster Hunter Rise v3.9.0.0 Added option to patch game function to render the Wirebug aim even when the Wirebug Gauge HUD is disabled. Added option to hide Overlay when the game is not focused. Added option to hide unknown parts (parts labeled as ???). Added Patreon button in HunterPie’s sidebar. HunterPie now reports crashes automatically to the developer. It’s now possible to scale a widget while in design mode by using the Mouse Scroll while hovering on the Widget. It’s now possible to change a widget’s opacity by pressing Ctrl + Mouse Scroll while hovering on the Widget.Wirebug WidgetThe Wirebug Widget tracks and displays all the useful information you need to know about your Wirebugs, as cooldown, timers and if they’re available or not. Its designed to replace the in-game Wirebug Gauge, however, you can also place it on top of the in-game UI too. Wirebug Widget example Tip: Refer to the documentation for more information.ClientThe HunterPie has also gotten a new visual to some elements in it’s client window New console window design New settings window designBug Fixes Fixed bug where HunterPie would try to render an invalid part and throw an error." }, { "title": "Wirebug Widget", "url": "/posts/wirebug-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-27 12:25:00 +0800", "snippet": "The Wirebug Widget is responsible for tracking and displaying all your Wirebugs information as cooldown, timer and if they’re available or not. This widget is quite simple and follows the same design as the in-game Wirebug gauge.Widget StructureIn-Game HUDReplacing the in-game Wirebug Gauge is quite simple, while in-game, open the HUD settings and disable the Wirebug Gauge. Attention: Disabling the in-game Wirebug Gauge also disables the Wirebug aim, to fix this, enable the Patch in-game Wirebug Aim option in your HunterPie’s Wirebug settings." }, { "title": "Localization", "url": "/posts/localization/", "categories": "Documentation, General", "tags": "", "date": "2022-02-18 11:07:00 +0800", "snippet": "HunterPie supports different languages other than English, if you want to localize it to another language make sure to read this because it covers everything you need to know to make your own localization file.LocalizationsThe supported languages are: Language Translated (%) Getting StartedRequirements A decent text editor, I personally recommend: Visual Studio Code Sublime Text Notepad++ The default strings file, you can find it here Tip: Do not use the default Windows’s notepad, that can cause file encoding issues and will make HunterPie fail to load your file. Make sure your encoding file is UTF-8.LocalizingNow thhat you have the requirements, it’s time to start translating!Use the en-us.xml you downloaded in the last step as a base file, it contains all the currently supported strings that are used by both the HunterPie client and the Overlay and the integrations. Warning: Make sure to rename your file to something else so it doesn’t conflict with the default files. If you don’t rename it, there’s a risk your local file will be overwritten during the auto-update process.Do not touch the first line of the XML Document, that is telling our XML parser the version and file encoding we are using. It should ALWAYS be the first line of the file and should always look like this:&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;!-- Comments can be added ONLY after the tag --&amp;gt;Next step is to set the language name, you can do it in the next Tag by changing the value of the lang attribute.&amp;lt;!-- Before --&amp;gt;&amp;lt;Strings lang=&quot;English&quot;&amp;gt;&amp;lt;!-- After --&amp;gt;&amp;lt;Strings lang=&quot;Japanese&quot;&amp;gt;Now we’re can translate the rest of the file, most localization Tags have three attributes: Id: Used internally by HunterPie to query the string and description. DO NOT TOUCH THIS VALUE String: The actual string that will be shown in HunterPie’s interface. Description: This one is only used in places where there can be a tooltip, e.g: Settings, Buttons Please, try to keep all translations as accurate as possible with the in-game strings (especially abnormalities and monster names). You can shorten long strings as long as they don’t become difficult to understand.E.g:&amp;lt;!-- Before --&amp;gt;&amp;lt;Rise&amp;gt; &amp;lt;Monster Id=&quot;0&quot; String=&quot;Rathian&quot;/&amp;gt; &amp;lt;Monster Id=&quot;1&quot; String=&quot;Apex Rathian&quot;/&amp;gt; &amp;lt;Monster Id=&quot;2&quot; String=&quot;Rathalos&quot;/&amp;gt; &amp;lt;Monster Id=&quot;3&quot; String=&quot;Apex Rathalos&quot;/&amp;gt; &amp;lt;Monster Id=&quot;4&quot; String=&quot;Khezu&quot;/&amp;gt; &amp;lt;Monster Id=&quot;5&quot; String=&quot;Basarios&quot;/&amp;gt; [...]&amp;lt;!-- After --&amp;gt;&amp;lt;Rise&amp;gt; &amp;lt;Monster Id=&quot;0&quot; String=&quot;リオレイア&quot;/&amp;gt; &amp;lt;Monster Id=&quot;1&quot; String=&quot;ヌシ・リオレイア&quot;/&amp;gt; &amp;lt;Monster Id=&quot;2&quot; String=&quot;リオレウス&quot;/&amp;gt; &amp;lt;Monster Id=&quot;3&quot; String=&quot;ヌシ・リオレウス&quot;/&amp;gt; &amp;lt;Monster Id=&quot;4&quot; String=&quot;フルフル&quot;/&amp;gt; &amp;lt;Monster Id=&quot;5&quot; String=&quot;バサルモス&quot;/&amp;gt; [...]XML Special CharactersXML has some characters that should be replaced by their escaped versions in order for it to work. This is because these characters are used in the XML’s structure itself, and the parser has a hard time figuring out whether it’s a XML character or if it’s just a normal character. Character Replaced by &amp;amp; &amp;amp;amp; &amp;lt; &amp;amp;lt; &amp;gt; &amp;amp;gt; ” &amp;amp;quot; ’ &amp;amp;apos; E.g:&amp;lt;!-- This will give us an error --&amp;gt;&amp;lt;Abnormality Id=&quot;ABNORMALITY_ATTACK_DEF_UP&quot; String=&quot;Attack &amp;amp; Def. Up&quot;/&amp;gt;&amp;lt;!-- This will work --&amp;gt;&amp;lt;Abnormality Id=&quot;ABNORMALITY_ATTACK_DEF_UP&quot; String=&quot;Attack &amp;amp;amp; Def. Up&quot;/&amp;gt;Sending my localizationNow that you’ve finished translating all strings, you can open a Pull Request to HunterPie’s repository or send it in the #translation-discussion channel in HunterPie’s official Discord Server. Making your own Pull Request is the preferred way, since it will also mark you as one of HunterPie’s contributors in GitHub, but if you have no Git experience sending the file directly to me on Discord is also fine." }, { "title": "Frequently Asked Questions", "url": "/posts/faq/", "categories": "Documentation, General", "tags": "", "date": "2022-02-17 02:42:00 +0800", "snippet": "Windows is asking me to install .NET 6, what do I do?HunterPie requires .NET 6.0 Desktop Runtime to run properly, you can download it from Microsoft’s official site by clicking here.Moving and Scaling WidgetsTo move a widget you can either use Design Mode (togglable by pressing the default hotkey: ScrollLock) or set the absolute coordinations in HunterPie’s settings.To scale a widget, you can go to HunterPie’s settings for that widget and use the Scale slider. For more information about widgets, check the Overlay and Widgets documentations.Why aren’t my settings saving?Make sure your HunterPie’s folder is not in read only mode, if that doesn’t work, try moving your HunterPie folder to somewhere else.My auto update is getting stuckSame as the previous issue, make sure your folder is not in read only mode, also try moving its folder somewhere else.My overlay seems delayedSome people has reported that as a Windows 11 issue, some known work arounds for that include: Changing rendering strategy to Software in HunterPie’s setttings. Enabling compatibility mode for HunterPie" }, { "title": "HunterPie v2.0.20", "url": "/posts/update-v2.0.20/", "categories": "Update, v2", "tags": "", "date": "2022-02-17 02:14:00 +0800", "snippet": "HunterPie v2.0.20 brings some new features and fixes.General Patch notes button now opens the current update patch notes in HunterPie’s documentation Added supporter tokens, allowing Patreons to receive beta updates Added some development options to the Advanced Debug ToolsAbnormality TraysAbnormality Trays are bars that track and display your character’s buff and debuff timers, they can be used in case you want to know how long your Hunting Horn buff will last, for example.As of now, HunterPie supports the following categories for buffs, not all of the buffs are supported, but they will be added whenever possible: Songs Consumables (this also includes environment buffs) Debuffs Gear skills Food skills Abnormality tray showing buffs and debuff Refer to the documentation for more information.Monster WidgetNew featuresMonster Widget has gotten some visual enhancements to the parts components, now it displays flinch, break and sever values. Since all parts have flinch values, the bars will still show that info once you can no longer break/sever it. Added horizontal orientation for Monster Widget. Added dynamic resizing for health bars depending on how many monsters the Widget is showing at the moment Added minimum width for Monster health bars Added flinch, severable and breakable partsPartsEach color represents a different type of part: Color Represents Description Flinch Flinch values represent when the monster is going to flinch or get staggered. Break Break values represent when a part is about to break. Sever Severable parts are the ones that can be cut off from a monster. Broken A part will become Grey when it’s either broken or severed. Severable partsSeverable parts are the parts that can be physically removed from the monster’s body, like tail and horns. Severable and Breakable partBreakable partsBreakable parts are the parts that can be broken, showing the “Part was broken” message in the game. Breakable and Flinch part Refer to the documentation for more information.Bug Fixes Fixed Somnacanth part order Fixed wrong Chameleos part order Fixed wrong pointer to monster flinch values, causing some monsters to not show any part data at all. Fixed bug where monsters would not despawn once dead. Fixed bug where HunterPie would show invalid parts before all valid parts. Fixed bug where HunterPie wouldn’t hide monster health percentage in Discord Rich Presence properly Fixed bug where HunterPie would fail to find game process due to cultural differences in UTF-8 characters" }, { "title": "Widgets", "url": "/posts/widgets/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-15 06:03:00 +0800", "snippet": "Widgets are part of HunterPie’s core, they’re the components that hold the widget’s content to display their data to the user.SettingsBy default, every widget has 6 default settings: Setting Description Initialize Widget When enabled, this Widget will be initialized when the game process is detected by HunterPie. Having this disabled is good for performance in case you’re not interested on what this Widget has to show. Show Widget When enabled, the Widget will be shown whenever it has content to be displayed, having this turned off will make it not show the Widget at all, however, it will still be in-memory tracking all data. Widget Opacity Sets the general widget opacity, the lower, the more transparent it will become. Widget Scale Sets the widget linear scale, 1 is the default scale, or 100% of it’s original scale, 2 means 200% of it’s original scale, therefore, making it 2x bigger. Streamer Mode Widgets are invisible to your system, making OBS fail to find them when you want to also record the overlay. This setting is a workaround for that OBS limitation. Widget Position Sets the absolute X and Y coordinates for this widget, this is relative to your main screen, values can be negative in case you have a screen on the left side of your main monitor. " }, { "title": "Monster Widget", "url": "/posts/monster-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-15 06:03:00 +0800", "snippet": "The Monster Widget is responsible to track and display all the big monsters information. It is one of the most complex widgets and each single component is designed to be simple without losing information.Widget StructureMonster PartsParts are represented by the blue, yellow and red bars under the ailments component. Their visual representation depends on what type of part it is: Color Represents Description Flinch Flinch values represent when the monster is going to flinch or get staggered. Break Break values represent when a part is about to break. Sever Severable parts are the ones that can be cut off from a monster. Broken A part will become Grey when it’s either broken or severed. Qurio* A part will become Pink when it’s related to the monster’s Qurio state. When a part has all three values, the priority order is always Qurio &amp;gt; Sever &amp;gt; Break &amp;gt; Flinch and the exact values displayed under the part health bar will follow that priority. By default, HunterPie only shows monsters’s parts when you lock/focus on the monster using the in-game lock-on system. A Qurio part is exclusive for Monster Hunter Rise: SunbreakMonster AilmentsAilments are statuses and debuffs you can inflict on a monster, HunterPie supports all of them, however, some of them might display as Unknown since ailments are mapped manually and require testing.They’re designed to be as simple to read as possible, displaying Build Up, Duration and also how many times that Ailment has been activated on that monster. Each ailment has it’s own individual color to make it easier to know what ailment has been inflicted without having to read it’s name. By default, HunterPie only shows monsters’s ailments when you lock/focus on the monster using the in-game lock-on system.Targeting a monsterHaving to target a monster to see their information is part of HunterPie’s design to avoid cluttering the screen with multiple monsters information, to target a monster, all you need to do is use the in-game lock-on system. If you have targeting system disabled in-game, this will not work. You must have either Target or Focus enabled.Capture indicatorFor capturable monsters, an upside down triangle () will be placed on the exact percentage where the monster will become capturable. Once it’s health falls into the capturable threshold, a shock trap icon () will be displayed.OrientationMonster Widget supports two orientations, Vertical and Horizontal Orientation Description Vertical Monster health bars will be placed on top of each other in the order they spawn Horizontal Monster healht bars will be placed side by side in the order they spawn Horizontally aligned barsDynamic ResizingDynamic resizing is one of the Monster Widget’s features, it’s very useful when your widget is in the Horizontal mode, it tries to calculate the health bar’s width dynamically instead of having a static width based on how many monsters the widget is displaying at that moment.The width is calculated based on the width set as Minimum Width, using the following formula:\\[dynWidth = min + ((3 - n) * {min \\over 4})\\] min: Minimum Width n: Number of monsters visibleSo, if you set the minimum width as 300, each possible case will result in these dynamic widths: Monsters visible Width (px) 3 300 2 375 1 450 Note: Even if the dynamic width is higher or lower than the maximum and minimum width respectively, the visual width will not go above/below those widths." }, { "title": "Overlay", "url": "/posts/overlay/", "categories": "Documentation, Overlay", "tags": "", "date": "2022-02-14 12:31:00 +0800", "snippet": "Overlay is one of HunterPie’s core features, it is responsible to manage every single Widget.Design ModeDesign Mode makes all Widgets visible to mouse events, making them clickable and allowing the user to interact with them. When Design Mode is active you can drag-and-drop Widgets with your mouse, scale linearly with your mouse scroll and also individually close a widget you don’t want to see anymore.To toggle design mode, you can use ScrollLock or whatever Hotkey you set in your HunterPie’s configuration." }, { "title": "Abnormality Tray Widget", "url": "/posts/abnormality-tray-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-14 00:23:00 +0800", "snippet": "The Abnormality Tray widget allows you to track your buff and debuff durations, it’s useful when playing Hunting Horn, or when you just want to know how long a certain buff will last. HunterPie lets you create as many trays as you want, allowing you to separate abnormalities in different trays. Keep in mind the more widgets you have on your screen, the more it impacts performance.Creating a new trayTo create a new tray, open HunterPie’s settings in the Abnormality Trays tab and click on the , in case you want to delete a specific tray, click on the , it will prompt you with a confirmation so you can delete the tray. If you’re creating new bars while the game is running, you’ll have to restart HunterPie in order for it to visually create the bar widget.Configuring the trayTo configure your new tray, click on the . It will open a new window that lets you configure all the tray settings individually.Enabling abnormalitiesIn the configuration window, there’s a panel with all the available abnormalities, clicking on one of them will automatically enable tracking that abnormality in that individual tray. Icon Description Enabled Disabled OrientationOrientation is the setting that indicates which direction your tray will grow to fit all abnormalities, setting it to Horizontal will make the tray grow sideways until it reaches its maximum width, on the other hand, Vertical will make the bar grow downwards until it reaches the maximum height.Maximum SizeSetting a maximum size to your tray will cause it to not grow infinitely, wrapping new abnormalities downwards (if the orientation is Horizontal) or sideways (if the orientation is Vertical)." } ]
